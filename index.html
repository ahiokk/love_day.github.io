<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>LOVE DAY - Валентинка для Маши</title>
    <style>
      :root {
        --bg-1: #fff2f5;
        --bg-2: #ffe8da;
        --bg-3: #ffe2ee;
        --card: rgba(255, 255, 255, 0.93);
        --ink: #2b1a1f;
        --muted: #7b4e59;
        --accent: #ff5c7a;
        --accent-2: #ff9b6b;
        --accent-3: #ffd36d;
        --accent-4: #ffc6d9;
        --shadow: 0 26px 60px rgba(120, 52, 64, 0.2);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at 20% 20%, var(--bg-1), transparent 45%),
          radial-gradient(circle at 80% 10%, var(--bg-3), transparent 45%),
          linear-gradient(140deg, var(--bg-2), var(--bg-1));
        color: var(--ink);
        font-family: "Palatino Linotype", "Book Antiqua", Palatino, serif;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 32px 16px 48px;
        overflow-x: hidden;
        position: relative;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image: radial-gradient(rgba(255, 255, 255, 0.35) 1px, transparent 1px);
        background-size: 22px 22px;
        opacity: 0.35;
        pointer-events: none;
      }

      .float-hearts {
        position: fixed;
        inset: 0;
        pointer-events: none;
        overflow: hidden;
        z-index: 0;
      }

      .float-heart {
        position: absolute;
        bottom: -20px;
        animation: floatUp var(--dur) linear infinite;
        animation-delay: var(--delay);
        opacity: 0.65;
        filter: blur(0.2px);
        font-weight: 700;
      }

      @keyframes floatUp {
        0% {
          transform: translateY(0) scale(0.8) rotate(0deg);
          opacity: 0;
        }
        10% {
          opacity: 0.7;
        }
        100% {
          transform: translateY(-120vh) scale(1.2) rotate(12deg);
          opacity: 0;
        }
      }

      .app {
        width: min(92vw, 560px);
        position: relative;
        z-index: 1;
      }

      .progress-row {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 16px;
      }

      .progress-text {
        font-family: "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        font-weight: 700;
        letter-spacing: 0.5px;
        font-size: 0.95rem;
        white-space: nowrap;
      }

      .progress-bar {
        flex: 1;
        height: 8px;
        background: rgba(255, 255, 255, 0.7);
        border-radius: 999px;
        overflow: hidden;
        box-shadow: inset 0 0 0 1px rgba(255, 92, 122, 0.15);
      }

      .progress-fill {
        height: 100%;
        width: 0;
        background: linear-gradient(90deg, var(--accent), var(--accent-2));
        border-radius: inherit;
        transition: width 0.35s ease;
        position: relative;
        overflow: hidden;
      }

      .progress-fill::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.6), transparent);
        transform: translateX(-100%);
        animation: shimmer 2.6s ease-in-out infinite;
      }

      @keyframes shimmer {
        100% {
          transform: translateX(100%);
        }
      }

      .card {
        background: linear-gradient(160deg, rgba(255, 255, 255, 0.98), rgba(255, 244, 248, 0.95));
        border-radius: 26px;
        padding: 28px 26px;
        min-height: 420px;
        box-shadow: var(--shadow);
        border: 1px solid rgba(255, 92, 122, 0.12);
        position: relative;
        overflow: hidden;
      }

      .card::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.65);
        pointer-events: none;
      }

      .card > * {
        position: relative;
        z-index: 1;
      }

      .card.animate-in {
        animation: cardIn 0.45s ease;
      }

      @keyframes cardIn {
        from {
          opacity: 0;
          transform: translateY(14px) scale(0.98);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      h1,
      h2,
      h3 {
        font-family: "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        margin: 0 0 12px;
      }

      p {
        margin: 0 0 14px;
        line-height: 1.55;
      }

      .muted {
        color: var(--muted);
      }

      .hidden {
        display: none;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 13px 18px;
        border-radius: 14px;
        border: none;
        font-size: 1rem;
        font-weight: 700;
        cursor: pointer;
        font-family: "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        --scale: 1;
        transform: scale(var(--scale, 1));
        transform-origin: center;
        transition: transform 0.15s ease, box-shadow 0.2s ease, opacity 0.2s ease;
        touch-action: manipulation;
      }

      .btn.primary {
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        color: #fff;
        box-shadow: 0 12px 22px rgba(255, 92, 122, 0.35);
      }

      .btn.secondary {
        background: #fff;
        color: var(--ink);
        border: 1px solid rgba(255, 92, 122, 0.3);
      }

      .btn:hover {
        transform: translateY(-1px) scale(var(--scale, 1));
      }

      .btn.primary:hover {
        box-shadow: 0 14px 26px rgba(255, 92, 122, 0.42);
      }

      .btn:active {
        transform: translateY(1px) scale(calc(var(--scale, 1) * 0.99));
      }

      .btn:disabled {
        opacity: 0.45;
        cursor: not-allowed;
        box-shadow: none;
      }

      .btn.block {
        width: 100%;
      }

      .btn.pulse {
        animation: pulse 2.4s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(var(--scale, 1));
        }
        50% {
          transform: scale(calc(var(--scale, 1) * 1.03));
        }
      }

      .btn-row {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-top: 10px;
      }

      button:focus-visible,
      .text-input:focus-visible {
        outline: 3px solid rgba(255, 92, 122, 0.45);
        outline-offset: 2px;
      }

      .burst-layer {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 2;
      }

      .burst-heart {
        position: absolute;
        left: 50%;
        top: 50%;
        font-size: 22px;
        transform: translate(-50%, -50%);
        animation: burst 1.5s ease-out forwards;
        --dx: 0px;
        --dy: 0px;
        --rot: 0deg;
      }

      .pop-heart {
        position: absolute;
        font-size: 16px;
        transform: translate(-50%, -50%);
        animation: pop 0.9s ease-out forwards;
        --dx: 0px;
        --dy: 0px;
        pointer-events: none;
      }

      @keyframes burst {
        0% {
          transform: translate(-50%, -50%) scale(0.8) rotate(0deg);
          opacity: 1;
        }
        100% {
          transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy)))
            scale(1.4) rotate(var(--rot));
          opacity: 0;
        }
      }

      @keyframes pop {
        0% {
          transform: translate(-50%, -50%) scale(0.6);
          opacity: 1;
        }
        100% {
          transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(1.2);
          opacity: 0;
        }
      }

      .mini-meter {
        height: 8px;
        background: rgba(255, 255, 255, 0.75);
        border-radius: 999px;
        overflow: hidden;
        box-shadow: inset 0 0 0 1px rgba(255, 92, 122, 0.15);
        margin: 12px 0 6px;
      }

      .mini-fill {
        height: 100%;
        width: 0;
        background: linear-gradient(90deg, var(--accent), var(--accent-3));
        border-radius: inherit;
        transition: width 0.5s ease;
      }

      .test-meta {
        font-size: 0.95rem;
        font-weight: 700;
        color: var(--muted);
      }

      .options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 10px;
        margin-top: 12px;
        margin-bottom: 12px;
      }

      .options .btn {
        font-weight: 600;
        font-size: 0.95rem;
      }

      .reaction {
        background: rgba(255, 156, 130, 0.15);
        border-radius: 14px;
        padding: 12px 14px;
        margin-top: 10px;
      }

      .arena {
        height: 240px;
        border-radius: 20px;
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.8), rgba(255, 222, 230, 0.6));
        border: 1px dashed rgba(255, 92, 122, 0.25);
        position: relative;
        overflow: hidden;
      }

      .runner-heart {
        position: absolute;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        border: none;
        background: #fff;
        box-shadow: 0 10px 18px rgba(255, 92, 122, 0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 28px;
        cursor: pointer;
        transition: transform 0.15s ease;
      }

      .runner-heart.caught {
        opacity: 0.45;
        cursor: default;
      }

      .reason-popup {
        margin-top: 14px;
        padding: 12px 14px;
        border-radius: 16px;
        background: rgba(255, 214, 186, 0.55);
        opacity: 0;
        transform: translateY(6px) scale(0.98);
        transition: opacity 0.25s ease, transform 0.25s ease;
        min-height: 64px;
      }

      .reason-popup.show {
        opacity: 1;
        transform: translateY(0) scale(1);
      }

      .note-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 12px;
        margin-top: 12px;
        position: relative;
      }

      .note-card {
        background: rgba(255, 243, 246, 0.8);
        border-radius: 16px;
        padding: 14px 12px;
        border: 1px solid rgba(255, 92, 122, 0.18);
        font-weight: 700;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .note-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 18px rgba(255, 92, 122, 0.2);
      }

      .note-card.done {
        opacity: 0.6;
        cursor: default;
        transform: none;
        box-shadow: none;
      }

      .note-panel {
        margin-top: 14px;
        padding: 12px 14px;
        border-radius: 16px;
        background: rgba(255, 214, 224, 0.45);
        min-height: 64px;
        opacity: 0;
        transform: translateY(6px);
        transition: opacity 0.25s ease, transform 0.25s ease;
      }

      .note-panel.show {
        opacity: 1;
        transform: translateY(0);
      }

      .petal-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(120px, 1fr));
        gap: 12px;
        margin-top: 12px;
        position: relative;
      }

      .petal-btn {
        background: rgba(255, 240, 245, 0.85);
        border-radius: 18px;
        padding: 16px 12px;
        font-weight: 700;
        border: 1px solid rgba(255, 92, 122, 0.2);
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .petal-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 18px rgba(255, 92, 122, 0.2);
      }

      .petal-btn.done {
        opacity: 0.6;
        cursor: default;
        transform: none;
        box-shadow: none;
      }

      .petal-panel {
        margin-top: 14px;
        padding: 12px 14px;
        border-radius: 16px;
        background: rgba(255, 226, 200, 0.45);
        min-height: 64px;
        opacity: 0;
        transform: translateY(6px);
        transition: opacity 0.25s ease, transform 0.25s ease;
      }

      .petal-panel.show {
        opacity: 1;
        transform: translateY(0);
      }

      .think-zone {
        margin-top: 10px;
        height: 140px;
        border-radius: 18px;
        background: rgba(255, 235, 244, 0.6);
        border: 1px dashed rgba(255, 92, 122, 0.35);
        position: relative;
        overflow: hidden;
      }

      .dodge-btn {
        position: absolute;
        left: 12px;
        top: 12px;
        transition: left 0.18s ease, top 0.18s ease, transform 0.15s ease;
      }

      .think-note {
        margin-top: 8px;
        font-size: 0.92rem;
        font-weight: 600;
        color: var(--muted);
      }

      .contract-list {
        display: grid;
        gap: 10px;
        margin: 12px 0 8px;
      }

      .contract-item {
        display: flex;
        gap: 10px;
        align-items: flex-start;
        font-size: 0.95rem;
        padding: 10px 12px;
        border-radius: 14px;
        background: rgba(255, 233, 226, 0.5);
      }

      .contract-item input {
        margin-top: 2px;
        accent-color: var(--accent);
      }

      .doc-scroll {
        max-height: 240px;
        overflow-y: auto;
        padding: 14px 16px;
        background: rgba(255, 246, 249, 0.7);
        border-radius: 18px;
        border: 1px solid rgba(255, 92, 122, 0.2);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.6);
      }

      .reason-scroll {
        max-height: 320px;
        overflow-y: auto;
        padding: 12px 12px;
        background: rgba(255, 246, 249, 0.7);
        border-radius: 18px;
        border: 1px solid rgba(255, 92, 122, 0.2);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.6);
      }

      .doc-scroll h3 {
        margin-top: 0;
        font-size: 1.05rem;
      }

      .doc-scroll h4 {
        margin: 12px 0 6px;
        font-size: 0.98rem;
      }

      .doc-scroll ul {
        margin: 8px 0 12px 18px;
        padding: 0;
      }

      .doc-scroll li {
        margin-bottom: 6px;
      }

      .doc-checks .contract-item {
        background: rgba(255, 229, 236, 0.55);
      }

      .text-input {
        flex: 1;
        padding: 12px 14px;
        border-radius: 12px;
        border: 1px solid rgba(255, 92, 122, 0.3);
        font-size: 1rem;
        font-family: "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        background: rgba(255, 255, 255, 0.95);
      }

      .hint {
        color: var(--accent);
        font-weight: 600;
        min-height: 22px;
      }

      .signature {
        margin-top: 12px;
        padding: 12px 14px;
        border-radius: 14px;
        background: rgba(255, 206, 120, 0.2);
        font-weight: 700;
      }

      .secret-boxes {
        display: grid;
        gap: 10px;
        margin-top: 12px;
      }

      .secret-box {
        background: rgba(255, 214, 224, 0.45);
        border-radius: 14px;
        padding: 12px 14px;
        font-weight: 600;
      }

      .small-note {
        margin-top: 18px;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .finale {
        margin-top: 16px;
        padding: 14px 16px;
        border-radius: 16px;
        background: rgba(255, 214, 224, 0.4);
        border: 1px solid rgba(255, 92, 122, 0.18);
      }

      .finale h3 {
        margin-top: 0;
      }

      .tap-heart {
        position: fixed;
        z-index: 3;
        pointer-events: none;
        font-size: 18px;
        animation: tapFloat 0.8s ease-out forwards;
      }

      @keyframes tapFloat {
        0% {
          transform: translate(-50%, -50%) scale(0.8);
          opacity: 0.9;
        }
        100% {
          transform: translate(-50%, -90%) scale(1.4);
          opacity: 0;
        }
      }

      .overlay {
        position: fixed;
        inset: 0;
        background: rgba(26, 18, 22, 0.45);
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        z-index: 4;
        padding: 24px;
      }

      .overlay.show {
        opacity: 1;
        pointer-events: auto;
      }

      .modal {
        background: #fff;
        border-radius: 20px;
        padding: 26px 24px;
        max-width: 420px;
        width: 100%;
        text-align: center;
        box-shadow: 0 18px 40px rgba(45, 20, 28, 0.35);
      }

      .confetti {
        position: fixed;
        top: -20px;
        animation: confettiFall var(--dur) ease-in forwards;
        z-index: 5;
        pointer-events: none;
        --rot: 0deg;
      }

      @keyframes confettiFall {
        0% {
          transform: translateY(-20px) rotate(var(--rot));
          opacity: 1;
        }
        100% {
          transform: translateY(110vh) rotate(calc(var(--rot) + 260deg));
          opacity: 0;
        }
      }

      @media (max-width: 520px) {
        .card {
          padding: 22px 18px;
          min-height: 400px;
        }

        .options {
          grid-template-columns: 1fr;
        }

        .btn-row {
          flex-direction: column;
        }

        .think-zone {
          height: 160px;
        }

        .reason-scroll {
          max-height: 260px;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        *,
        *::before,
        *::after {
          animation-duration: 0.001ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.001ms !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="float-hearts" id="floatHearts" aria-hidden="true"></div>
    <main class="app" aria-live="polite">
      <div class="progress-row">
        <div class="progress-text" id="progressText">Шаг 1 / 10</div>
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
      </div>
      <section class="card" id="card"></section>
    </main>
    <div class="overlay" id="overlay" aria-hidden="true"></div>

    <script>
      const state = {
        step: 1,
        testIndex: 0,
        heartsCaught: 0,
        yesClicks: 0,
        contractChecks: [false, false, false, false, false],
        contractSigned: false,
        secretUnlocked: false,
        signatureText: "",
        signatureDate: "",
        cleanups: [],
        audioCtx: null,
      };

      const totalSteps = 10;
      const card = document.getElementById("card");
      const progressText = document.getElementById("progressText");
      const progressFill = document.getElementById("progressFill");
      const overlay = document.getElementById("overlay");
      const floatHearts = document.getElementById("floatHearts");
      const loveSymbols = ["💖", "💗", "💘", "💞", "💕", "❤️", "✨"];
      const floatSymbols = [...loveSymbols, "И+М", "Иракли+Маша", "Чикобава+Иващенко"];

      const testQuestions = [
        {
          q: "Что в тебе самое классное? 💗",
          options: ["Улыбка", "Глаза", "Характер", "Всё сразу"],
          correctIndex: 3,
          responses: [
            "Я обожаю твою улыбку, она лечит день. Но правильный ответ ещё шире 💖",
            "Твои глаза сводят меня с ума. Но это не всё ❤️",
            "Твой характер — мой любимый. Но есть кое-что большее ✨",
            "Правильно: всё сразу. Ты целиком моё чудо 💘",
          ],
        },
        {
          q: "Как я тебя называю, когда проявляю любовь? 💞",
          options: ["Милый котенок", "Бусинка", "Солнышко", "Все варианты"],
          correctIndex: 3,
          responses: [
            "Да, мой милый котенок, и это только часть правды 💗",
            "Бусинка — да! Но есть ещё слова от сердца ❤️",
            "Солнышко — точно. Ты греешь меня всегда 💛",
            "Правильно: все варианты. Ты у меня вся любовь сразу 💖",
          ],
        },
        {
          q: "Что я обожаю в тебе больше всего? 💫",
          options: ["Смех", "Обнимашки", "Тепло", "Всё вместе"],
          correctIndex: 3,
          responses: [
            "Я обожаю твой смех, но не только — я люблю всё в тебе 💗",
            "Обнимашки волшебные, но я люблю больше, чем это 💞",
            "Твоё тепло — мой дом. Но есть ещё кое-что 💖",
            "Правильно: всё вместе. Ты целиком моё счастье 💘",
          ],
        },
        {
          q: "Что я хочу делать рядом с тобой? 💌",
          options: ["Быть рядом всегда", "Беречь тебя", "Радовать тебя", "Всё сразу"],
          correctIndex: 3,
          responses: [
            "Быть рядом всегда — да. Но это ещё не всё 💗",
            "Беречь тебя — обязательно. Но есть ещё кое-что 💞",
            "Радовать тебя — всегда. Но я хочу больше ❤️",
            "Правильно: всё сразу. Я хочу дарить тебе всё это каждый день 💖",
          ],
        },
        {
          q: "Самый честный факт про нас? ❤️",
          options: ["Мы команда", "Я люблю тебя больше всего", "Ты самая красивая на свете", "Все варианты"],
          correctIndex: 3,
          responses: [
            "Мы команда — да. Но правда ещё больше 💗",
            "Я люблю тебя больше всего — правда. Но это не одно 💞",
            "Ты самая красивая на свете — факт. Но есть ещё 💖",
            "Правильно: все варианты. Что бы ни случалось, я всегда буду любить тебя 💘",
          ],
        },
      ];

      const heartReasons = [
        "Ты — мой уют. С тобой всё становится проще и теплее 💗",
        "Ты мой милый котенок. Я люблю тебя нежно и глубоко 💞",
        "Даже если мы спорим или что-то не понимаем, я всегда буду любить тебя 💖",
        "Ты самая красивая на свете — и внутри, и снаружи ❤️",
        "Я люблю тебя больше всего и хочу быть рядом каждый день 💘",
      ];

      const loveNotes = [
        { label: "Письмо 1 💌", text: "Я хочу быть с тобой каждый день и просыпаться в твоих объятиях. 💗" },
        {
          label: "Письмо 2 💌",
          text: "Твои руки нежнее всего на свете. Когда ты меня гладишь, я схожу с ума от счастья. ❤️",
        },
        { label: "Письмо 3 💌", text: "Какие бы споры ни были, я всегда буду любить тебя. 💖" },
      ];

      const bouquetPetals = [
        { label: "Лепесток нежности 🌸", text: "Ты очень вкусно готовишь, и я таю от твоей заботы. 🍲💞" },
        { label: "Лепесток счастья 🌷", text: "С тобой мне спокойно и светло каждый день. 💗" },
        { label: "Лепесток верности 🌹", text: "Я всегда рядом и всегда за тебя. 💘" },
        { label: "Лепесток красоты 🌼", text: "Ты самая красивая на свете — и в сердце, и в мире. ❤️" },
      ];

      const loveReasons = [
        "Потому что ты — моя Маша.",
        "Потому что ты моя бусинка.",
        "Потому что рядом с тобой мир становится спокойнее.",
        "Потому что ты умеешь смеяться так, что я тоже начинаю.",
        "Потому что твоя улыбка лечит усталость.",
        "Потому что ты красивая даже когда “просто дома”.",
        "Потому что ты милая даже когда делаешь вид, что строгая.",
        "Потому что ты умная, и это прям заметно.",
        "Потому что с тобой интересно говорить обо всём.",
        "Потому что с тобой приятно молчать.",
        "Потому что ты умеешь поддержать одним взглядом.",
        "Потому что ты умеешь сделать день лучше одной фразой.",
        "Потому что ты умеешь радоваться мелочам.",
        "Потому что ты умеешь быть нежной.",
        "Потому что ты умеешь быть сильной.",
        "Потому что ты настоящая.",
        "Потому что ты смешная. Опасно смешная.",
        "Потому что ты умеешь подколоть ровно в точку.",
        "Потому что твой юмор — мой любимый жанр.",
        "Потому что ты умеешь быть “домом”.",
        "Потому что я люблю твоё лицо (да, всё целиком).",
        "Потому что мне нравится, как ты смотришь.",
        "Потому что мне нравится, как ты говоришь.",
        "Потому что мне нравится, как ты реагируешь на мои глупости.",
        "Потому что ты умеешь делать “ну ладно” милым.",
        "Потому что ты умеешь превращать обычные моменты в особенные.",
        "Потому что рядом с тобой я хочу стараться.",
        "Потому что рядом с тобой я становлюсь лучше.",
        "Потому что ты умеешь вдохновлять.",
        "Потому что ты веришь в меня (даже когда я сам торможу).",
        "Потому что твои обнимашки — это официальная терапия.",
        "Потому что твои поцелуи делают голову пустой и счастливой.",
        "Потому что ты умеешь быть ласковой.",
        "Потому что ты умеешь быть заботливой.",
        "Потому что ты умеешь быть терпеливой (и это подвиг).",
        "Потому что с тобой тепло.",
        "Потому что ты умеешь успокоить.",
        "Потому что ты умеешь поднять настроение.",
        "Потому что ты умеешь быть рядом по-настоящему.",
        "Потому что ты — моя безопасность.",
        "Потому что ты умеешь слушать.",
        "Потому что ты замечаешь детали.",
        "Потому что ты не боишься быть собой.",
        "Потому что ты умеешь признавать, когда что-то не так.",
        "Потому что ты умеешь говорить честно.",
        "Потому что ты умеешь мириться красиво.",
        "Потому что ты умеешь заботиться о тех, кого любишь.",
        "Потому что ты добрая (даже если прячешь это за шутками).",
        "Потому что ты нежная (даже когда включаешь “характер”).",
        "Потому что ты офигенная.",
        "Потому что у нас есть наши шутки.",
        "Потому что писЯЯт дваАААа.",
        "Потому что у нас есть “наебательный процесс”.",
        "Потому что ты запускаешь “наебательный процесс” очаровательно.",
        "Потому что ты хитришь мило, и я всё равно улыбаюсь.",
        "Потому что ты умеешь делать вид “я ни при чём” лучше всех.",
        "Потому что я люблю, когда ты пытаешься меня обмануть (немножко).",
        "Потому что ты умеешь провернуть “наебательный процесс” так красиво, что я даже горжусь, что меня обманули. 😌",
        "Потому что ты умеешь выигрывать спор так, что я не злюсь.",
        "Потому что ты — мой любимый соперник и мой любимый союзник.",
        "Потому что мне нравится твой стиль.",
        "Потому что мне нравится твой вкус.",
        "Потому что мне нравится, как ты выбираешь вещи.",
        "Потому что мне нравится, как ты реагируешь на сюрпризы.",
        "Потому что мне нравится делать тебе приятное.",
        "Потому что ты красиво радуешься.",
        "Потому что ты красиво смущаешься.",
        "Потому что ты красиво злишься (чуть-чуть).",
        "Потому что ты умеешь быть разной.",
        "Потому что ты всегда ты.",
        "Потому что с тобой даже самые странные шутки становятся милыми.",
        "Потому что ты смеёшься со мной, а не “на меня” — и это бесценно.",
        "Потому что у нас есть свои маленькие приколы, которые понятны только нам.",
        "Потому что рядом с тобой я счастливый идиот (в хорошем смысле).",
        "Потому что ты принимаешь мои глупости.",
        "Потому что ты не делаешь меня “слишком серьёзным”.",
        "Потому что с тобой можно быть дурачком.",
        "Потому что с тобой можно быть взрослым.",
        "Потому что с тобой можно быть любым — и это безопасно.",
        "Потому что я рядом с тобой “свой”.",
        "Потому что ты умеешь удивлять.",
        "Потому что ты умеешь делать неожиданно хорошо.",
        "Потому что ты умеешь делать смешно там, где надо.",
        "Потому что ты умеешь делать нежно там, где важно.",
        "Потому что когда ты берёшь меня за руку, у меня внутри всё становится на свои места.",
        "Потому что ты умеешь находить свет даже в плохой день.",
        "Потому что ты не сдаёшься легко.",
        "Потому что ты смелая.",
        "Потому что ты внимательная.",
        "Потому что ты очень-очень моя.",
        "Потому что я люблю наши “мы”.",
        "Потому что я люблю нашу близость.",
        "Потому что я люблю наши планы.",
        "Потому что я люблю наши случайные моменты.",
        "Потому что я люблю, как ты делаешь мой день важным.",
        "Потому что я люблю, как ты меняешь мою жизнь.",
        "Потому что я люблю, как ты смеёшься именно со мной.",
        "Потому что я люблю тебя даже когда ты вредничаешь (особенно тогда).",
        "Потому что я люблю тебя без условий.",
        "Потому что ты — моя любовь. И моя валентинка. 💘",
      ];

      const personNames = {
        her: "Иващенко Мария Александровна",
        him: "Чикобава Иракли Леванович",
      };

      const agreementHtml = `
        <h3>ДОГОВОР О ЛЮБВИ И ВАЛЕНТИНОЧНОМ СОЮЗЕ № 14/02</h3>
        <p class="muted">(редакция: «Маша — бусинка»)</p>
        <p>Сторона А: Я, влюблённый гражданин (далее — “Я”).</p>
        <p>Сторона Б: Маша, официальная Бусинка, милая и прекрасная (далее — “Ты”).</p>
        <p><strong>Совместно именуемые “Мы”, заключили настоящий Договор о любви (далее — “Договор”) на следующих условиях:</strong></p>
        <h4>1. Предмет Договора</h4>
        <p>1.1. “Я” торжественно подтверждаю: люблю “Тебя” сильно, стабильно, с тенденцией к усилению.</p>
        <p>1.2. “Ты” подтверждаешь готовность быть моей валентинкой (в рамках настоящего Договора и здравого смысла).</p>
        <h4>2. Основные положения</h4>
        <p>2.1. “Ты” признаёшь, что являешься милой, бусинкой и прекрасной. Оспаривание пунктов 2.1 запрещено как бессмысленное.</p>
        <p>2.2. “Я” обязуюсь:</p>
        <ul>
          <li>обнимать “Тебя” при первой возможности (и иногда без предупреждения),</li>
          <li>заботиться, поддерживать и смешить,</li>
          <li>уважать твои границы и настроение,</li>
          <li>не забывать говорить, что ты чудо.</li>
        </ul>
        <p>2.3. “Ты” имеешь право:</p>
        <ul>
          <li>требовать обнимашки,</li>
          <li>отправлять мемы,</li>
          <li>говорить “ой всё” без объяснений,</li>
          <li>запускать “наебательный процесс” исключительно в развлекательных целях.</li>
        </ul>
        <h4>3. О наебательном процессе</h4>
        <p>3.1. Под “наебательным процессом” понимается любая попытка “Тебя” меня перехитрить, подколоть или сделать вид, что ты ни при чём.</p>
        <p>3.2. В случае запуска процесса “Я” обязан:</p>
        <ul>
          <li>сделать вид, что я строгий,</li>
          <li>но на самом деле улыбнуться,</li>
          <li>а потом всё равно тебя поцеловать (если разрешено обстоятельствами).</li>
        </ul>
        <p>3.3. “Наебательный процесс” не считается нарушением, если “Ты” при этом остаёшься бусинкой (что происходит всегда).</p>
        <h4>4. Особый статус правой руки</h4>
        <p>4.1. “Я” официально признаю: у “Твоей правой руки” есть VIP-статус в моём сердце.</p>
        <p>4.2. “Ты” подтверждаешь, что шутка про мою “слишком сильную любовь к правой руке” является:</p>
        <ul>
          <li>странной,</li>
          <li>смешной,</li>
          <li>и почему-то очень нашей.</li>
        </ul>
        <p>4.3. VIP-статус не отменяет любви ко всей “Тебе” целиком (наоборот, усиливает).</p>
        <h4>5. Срок действия</h4>
        <p>5.1. Договор вступает в силу с момента нажатия кнопки “Подписать ❤️”.</p>
        <p>5.2. Срок действия: бессрочно, с автоматическим продлением каждый раз, когда “Ты” улыбаешься.</p>
        <h4>6. Заключительные положения</h4>
        <p>6.1. Споры решаются обнимашками, разговорами и (при необходимости) вкусняшками.</p>
        <p>6.2. Настоящий Договор составлен в одном экземпляре, который хранится в моём сердце и немножко в браузере.</p>
        <p>6.3. Нажимая “Подписать”, “Ты” подтверждаешь: “Да, я — валентинка, и да, он меня любит”.</p>
      `;

      const agreementPdfLines = [
        "ДОГОВОР О ЛЮБВИ И ВАЛЕНТИНОЧНОМ СОЮЗЕ № 14/02",
        "(редакция: «Маша — бусинка»)",
        "",
        "Сторона А: Я, влюблённый гражданин (далее — “Я”).",
        "Сторона Б: Маша, официальная Бусинка, милая и прекрасная (далее — “Ты”).",
        "",
        "Совместно именуемые “Мы”, заключили настоящий Договор о любви (далее — “Договор”) на следующих условиях:",
        "",
        "1. Предмет Договора",
        "1.1. “Я” торжественно подтверждаю: люблю “Тебя” сильно, стабильно, с тенденцией к усилению.",
        "1.2. “Ты” подтверждаешь готовность быть моей валентинкой (в рамках настоящего Договора и здравого смысла).",
        "",
        "2. Основные положения",
        "2.1. “Ты” признаёшь, что являешься милой, бусинкой и прекрасной. Оспаривание пунктов 2.1 запрещено как бессмысленное.",
        "2.2. “Я” обязуюсь:",
        " - обнимать “Тебя” при первой возможности (и иногда без предупреждения),",
        " - заботиться, поддерживать и смешить,",
        " - уважать твои границы и настроение,",
        " - не забывать говорить, что ты чудо.",
        "2.3. “Ты” имеешь право:",
        " - требовать обнимашки,",
        " - отправлять мемы,",
        " - говорить “ой всё” без объяснений,",
        " - запускать “наебательный процесс” исключительно в развлекательных целях.",
        "",
        "3. О наебательном процессе",
        "3.1. Под “наебательным процессом” понимается любая попытка “Тебя” меня перехитрить, подколоть или сделать вид, что ты ни при чём.",
        "3.2. В случае запуска процесса “Я” обязан:",
        " - сделать вид, что я строгий,",
        " - но на самом деле улыбнуться,",
        " - а потом всё равно тебя поцеловать (если разрешено обстоятельствами).",
        "3.3. “Наебательный процесс” не считается нарушением, если “Ты” при этом остаёшься бусинкой (что происходит всегда).",
        "",
        "4. Особый статус правой руки",
        "4.1. “Я” официально признаю: у “Твоей правой руки” есть VIP-статус в моём сердце.",
        "4.2. “Ты” подтверждаешь, что шутка про мою “слишком сильную любовь к правой руке” является:",
        " - странной,",
        " - смешной,",
        " - и почему-то очень нашей.",
        "4.3. VIP-статус не отменяет любви ко всей “Тебе” целиком (наоборот, усиливает).",
        "",
        "5. Срок действия",
        "5.1. Договор вступает в силу с момента нажатия кнопки “Подписать ❤️”.",
        "5.2. Срок действия: бессрочно, с автоматическим продлением каждый раз, когда “Ты” улыбаешься.",
        "",
        "6. Заключительные положения",
        "6.1. Споры решаются обнимашками, разговорами и (при необходимости) вкусняшками.",
        "6.2. Настоящий Договор составлен в одном экземпляре, который хранится в моём сердце и немножко в браузере.",
        "6.3. Нажимая “Подписать”, “Ты” подтверждаешь: “Да, я — валентинка, и да, он меня любит”.",
      ];

      function addCleanup(fn) {
        state.cleanups.push(fn);
      }

      function runCleanups() {
        while (state.cleanups.length) {
          const fn = state.cleanups.pop();
          try {
            fn();
          } catch (error) {
            console.error(error);
          }
        }
      }

      function beep(freq = 640, duration = 0.08) {
        try {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          if (!AudioContext) return;
          if (!state.audioCtx) state.audioCtx = new AudioContext();
          const ctx = state.audioCtx;
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          gain.gain.value = 0.05;
          osc.frequency.value = freq;
          osc.type = "triangle";
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.start();
          osc.stop(ctx.currentTime + duration);
        } catch (error) {
          console.warn(error);
        }
      }

      function updateProgress() {
        progressText.textContent = `Шаг ${state.step} / ${totalSteps}`;
        progressFill.style.width = `${(state.step / totalSteps) * 100}%`;
      }

      function animateCard() {
        card.classList.remove("animate-in");
        void card.offsetWidth;
        card.classList.add("animate-in");
      }

      function focusPrimary() {
        const btn = card.querySelector(".btn.primary:not([disabled])") || card.querySelector("button");
        if (btn) setTimeout(() => btn.focus(), 60);
      }

      function burstHearts(container, amount = 18) {
        for (let i = 0; i < amount; i++) {
          const heart = document.createElement("span");
          heart.className = "burst-heart";
          heart.textContent = loveSymbols[Math.floor(Math.random() * loveSymbols.length)];
          const angle = Math.random() * Math.PI * 2;
          const distance = 40 + Math.random() * 120;
          heart.style.setProperty("--dx", `${Math.cos(angle) * distance}px`);
          heart.style.setProperty("--dy", `${Math.sin(angle) * distance}px`);
          heart.style.setProperty("--rot", `${Math.random() * 140 - 70}deg`);
          container.appendChild(heart);
          setTimeout(() => heart.remove(), 1600);
        }
      }

      function popHeartsAt(container, x, y, amount = 8) {
        for (let i = 0; i < amount; i++) {
          const heart = document.createElement("span");
          heart.className = "pop-heart";
          heart.textContent = loveSymbols[Math.floor(Math.random() * loveSymbols.length)];
          const angle = Math.random() * Math.PI * 2;
          const distance = 14 + Math.random() * 34;
          heart.style.left = `${x}px`;
          heart.style.top = `${y}px`;
          heart.style.setProperty("--dx", `${Math.cos(angle) * distance}px`);
          heart.style.setProperty("--dy", `${Math.sin(angle) * distance}px`);
          container.appendChild(heart);
          setTimeout(() => heart.remove(), 900);
        }
      }

      function initFloatingHearts() {
        if (!floatHearts) return;
        const amount = 18;
        for (let i = 0; i < amount; i++) {
          const heart = document.createElement("span");
          const symbol = floatSymbols[Math.floor(Math.random() * floatSymbols.length)];
          heart.className = "float-heart";
          heart.textContent = symbol;
          heart.style.left = `${Math.random() * 100}%`;
            const isName = symbol.includes("+");
            const isLong = symbol.length > 6;
            const baseSize = isLong ? 10 : symbol === "И+М" ? 18 : 14;
            const variance = isLong ? 8 : 18;
            heart.style.fontSize = `${baseSize + Math.random() * variance}px`;
            if (isName) {
              heart.style.letterSpacing = symbol === "И+М" ? "1px" : "0.5px";
            }
          heart.style.setProperty("--dur", `${8 + Math.random() * 6}s`);
          heart.style.setProperty("--delay", `${-Math.random() * 8}s`);
          heart.style.opacity = `${0.35 + Math.random() * 0.4}`;
          floatHearts.appendChild(heart);
        }
      }

      function createTapHeart(x, y) {
        const heart = document.createElement("span");
        heart.className = "tap-heart";
        heart.textContent = loveSymbols[Math.floor(Math.random() * loveSymbols.length)];
        heart.style.left = `${x}px`;
        heart.style.top = `${y}px`;
        document.body.appendChild(heart);
        setTimeout(() => heart.remove(), 800);
      }

      function setupTapHearts() {
        document.addEventListener("click", (event) => {
          if (!event.target.closest(".btn")) return;
          createTapHeart(event.clientX, event.clientY);
        });
      }

      function buildAgreementHtml() {
        return agreementHtml;
      }

      function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        if (!text) return y + lineHeight * 0.6;
        const words = text.split(" ");
        let line = "";
        for (let i = 0; i < words.length; i++) {
          const testLine = `${line}${words[i]} `;
          if (ctx.measureText(testLine).width > maxWidth && line) {
            ctx.fillText(line.trim(), x, y);
            line = `${words[i]} `;
            y += lineHeight;
          } else {
            line = testLine;
          }
        }
        if (line) {
          ctx.fillText(line.trim(), x, y);
          y += lineHeight;
        }
        return y;
      }

      function base64ToUint8Array(base64) {
        const raw = atob(base64);
        const bytes = new Uint8Array(raw.length);
        for (let i = 0; i < raw.length; i++) {
          bytes[i] = raw.charCodeAt(i);
        }
        return bytes;
      }

      function buildPdfBlob(jpegBytes, width, height) {
        const encoder = new TextEncoder();
        const parts = [];
        const offsets = [0];
        let length = 0;

        function pushBytes(bytes) {
          parts.push(bytes);
          length += bytes.length;
        }

        function pushText(text) {
          const bytes = encoder.encode(text);
          pushBytes(bytes);
        }

        function markOffset() {
          offsets.push(length);
        }

        function padOffset(value) {
          return String(value).padStart(10, "0");
        }

        pushText("%PDF-1.3\n");

        markOffset();
        pushText("1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n");

        markOffset();
        pushText("2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n");

        markOffset();
        pushText(
          `3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 ${width} ${height}] ` +
            `/Resources << /XObject << /Im0 4 0 R >> /ProcSet [/PDF /ImageC] >> ` +
            `/Contents 5 0 R >>\nendobj\n`
        );

        markOffset();
        pushText(
          `4 0 obj\n<< /Type /XObject /Subtype /Image /Width ${width} /Height ${height} ` +
            `/ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /DCTDecode /Length ${jpegBytes.length} >>\nstream\n`
        );
        pushBytes(jpegBytes);
        pushText("\nendstream\nendobj\n");

        const contentStream = `q\n${width} 0 0 ${height} 0 0 cm\n/Im0 Do\nQ\n`;
        markOffset();
        pushText(
          `5 0 obj\n<< /Length ${contentStream.length} >>\nstream\n${contentStream}endstream\nendobj\n`
        );

        const xrefOffset = length;
        pushText("xref\n0 6\n");
        pushText("0000000000 65535 f \n");
        for (let i = 1; i < offsets.length; i++) {
          pushText(`${padOffset(offsets[i])} 00000 n \n`);
        }

        pushText(`trailer\n<< /Size 6 /Root 1 0 R >>\nstartxref\n${xrefOffset}\n%%EOF`);

        return new Blob(parts, { type: "application/pdf" });
      }

      function buildAgreementPdf(signatureLine, dateLine) {
        const width = 595;
        const height = 842;
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = "#2b1a1f";
        ctx.textBaseline = "top";

        let y = 40;
        ctx.font = "bold 18px \"Times New Roman\", serif";
        y = wrapText(ctx, agreementPdfLines[0], 40, y, width - 80, 24) + 6;
        ctx.font = "italic 13px \"Times New Roman\", serif";
        y = wrapText(ctx, agreementPdfLines[1], 40, y, width - 80, 18) + 6;
        ctx.font = "14px \"Times New Roman\", serif";

        agreementPdfLines.slice(2).forEach((line) => {
          if (!line) {
            y += 12;
            return;
          }
          y = wrapText(ctx, line, 40, y, width - 80, 20);
        });

        if (signatureLine) {
          y += 10;
          ctx.font = "bold 14px \"Times New Roman\", serif";
          y = wrapText(ctx, signatureLine, 40, y, width - 80, 20);
          ctx.font = "12px \"Times New Roman\", serif";
          if (dateLine) {
            y = wrapText(ctx, dateLine, 40, y, width - 80, 18);
          }
        }

        const dataUrl = canvas.toDataURL("image/jpeg", 0.92);
        const jpegBytes = base64ToUint8Array(dataUrl.split(",")[1]);
        return buildPdfBlob(jpegBytes, width, height);
      }

      function downloadAgreementPdf(signatureLine, dateLine) {
        const blob = buildAgreementPdf(signatureLine, dateLine);
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "love_day_agreement.pdf";
        document.body.appendChild(link);
        link.click();
        link.remove();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      }

      function showOverlay(title, text) {
        overlay.innerHTML = `
          <div class="modal">
            <h2>${title}</h2>
            <p>${text}</p>
            <button class="btn primary" id="closeOverlay" type="button">Обнять ❤️</button>
          </div>
        `;
        overlay.classList.add("show");
        overlay.setAttribute("aria-hidden", "false");
        const closeBtn = document.getElementById("closeOverlay");
        closeBtn.addEventListener("click", () => {
          overlay.classList.remove("show");
          overlay.setAttribute("aria-hidden", "true");
          closeBtn.blur();
        });
      }

      const steps = {
        1: {
          template: () => `
            <h1>Маша, система сердца перегрелась от милоты 💥</h1>
            <p id="loadingLine">Идёт загрузка чувств…</p>
            <p id="loadingSub" class="muted">Запускаю протокол «любовь»…</p>
            <div class="mini-meter">
              <div class="mini-fill" id="loadingFill"></div>
            </div>
            <p id="errorLine" class="muted hidden">Ошибка: уровень «бусинка» превышает допустимый. Сердце переполнено любовью ❤️</p>
            <div class="burst-layer" id="burstLayer" aria-hidden="true"></div>
            <div class="btn-row">
              <button class="btn primary pulse" id="restartBtn" type="button" disabled>Перезапустить сердечко для Маши ❤️</button>
            </div>
          `,
          init: () => {
            const loadingLine = document.getElementById("loadingLine");
            const loadingSub = document.getElementById("loadingSub");
            const loadingFill = document.getElementById("loadingFill");
            const errorLine = document.getElementById("errorLine");
            const restartBtn = document.getElementById("restartBtn");
            const burstLayer = document.getElementById("burstLayer");
            const stages = [
              { line: "Идёт загрузка чувств…", sub: "Запускаю протокол «любовь» 💗", percent: 10, delay: 0 },
              { line: "Проверяю сердце…", sub: "Пульс любви стабилен", percent: 18, delay: 1200 },
              { line: "Сканирую улыбку Маши…", sub: "Нежность растёт", percent: 28, delay: 1200 },
              { line: "Подкачиваю обнимашки…", sub: "Тепло увеличивается", percent: 40, delay: 1200 },
              { line: "Добавляю ласку и заботу…", sub: "Маша — мой милый котенок", percent: 52, delay: 1200 },
              { line: "Загружаю поцелуи…", sub: "Любовь заполняет всё", percent: 66, delay: 1200 },
              { line: "Сохраняю «ты самая красивая»…", sub: "Истина подтверждена", percent: 78, delay: 1200 },
              { line: "Финальная проверка…", sub: "Предел близко", percent: 92, delay: 1200 },
            ];

            let totalDelay = 0;

            function applyStage(stage) {
              loadingLine.textContent = `${stage.line} ${stage.percent}%`;
              loadingSub.textContent = stage.sub;
              loadingFill.style.width = `${stage.percent}%`;
            }

            stages.forEach((stage) => {
              totalDelay += stage.delay;
              const timer = setTimeout(() => applyStage(stage), totalDelay);
              addCleanup(() => clearTimeout(timer));
            });

            const boomTimer = setTimeout(() => {
              errorLine.classList.remove("hidden");
              burstHearts(burstLayer, 26);
              loadingFill.style.width = "100%";
              restartBtn.disabled = false;
              beep(520);
              focusPrimary();
            }, totalDelay + 900);

            addCleanup(() => clearTimeout(boomTimer));
            restartBtn.addEventListener("click", () => {
              beep(680);
              nextStep();
            });
          },
        },
        2: {
          template: () => `
            <h2>Мини-тест на легендарность Маши 💖</h2>
            <p class="muted">В каждом вопросе есть один самый верный ответ. Выбирай сердцем 💖</p>
            <div class="test-meta" id="testMeta"></div>
            <h3 id="testQuestion"></h3>
            <div class="options" id="testOptions"></div>
            <div class="reaction hidden" id="testReaction"></div>
          `,
          init: () => {
            state.testIndex = 0;
            const testMeta = document.getElementById("testMeta");
            const testQuestion = document.getElementById("testQuestion");
            const testOptions = document.getElementById("testOptions");
            const testReaction = document.getElementById("testReaction");
            let lock = false;

            function renderQuestion() {
              const current = testQuestions[state.testIndex];
              testMeta.textContent = `Вопрос ${state.testIndex + 1} / ${testQuestions.length}`;
              testQuestion.textContent = current.q;
              testOptions.innerHTML = "";
              testReaction.classList.add("hidden");
              lock = false;

              current.options.forEach((option, index) => {
                const btn = document.createElement("button");
                btn.className = "btn secondary";
                btn.type = "button";
                btn.textContent = option;
                btn.addEventListener("click", () => {
                  if (lock) return;
                  testReaction.textContent = current.responses[index];
                  testReaction.classList.remove("hidden");
                  if (index === current.correctIndex) {
                    lock = true;
                    [...testOptions.querySelectorAll("button")].forEach((b) => (b.disabled = true));
                    popHeartsAt(card, card.clientWidth / 2, 160, 10);
                    beep(760);
                    const timer = setTimeout(() => {
                      if (state.testIndex < testQuestions.length - 1) {
                        state.testIndex += 1;
                        renderQuestion();
                      } else {
                        nextStep();
                      }
                      }, 3000);
                    addCleanup(() => clearTimeout(timer));
                  } else {
                    beep(460);
                  }
                });
                testOptions.appendChild(btn);
              });
            }

            renderQuestion();
            focusPrimary();
          },
        },
        3: {
          template: () => `
            <h2>Тёплые письма для Маши 💌</h2>
            <p class="muted">Открой все три письма, чтобы услышать, как сильно я тебя люблю.</p>
            <div class="test-meta">Открыто: <span id="notesCount">0/3</span></div>
            <div class="note-grid" id="noteGrid">
              ${loveNotes
                .map(
                  (note, index) =>
                    `<button class="note-card" type="button" data-index="${index}">${note.label}</button>`
                )
                .join("")}
            </div>
            <div class="note-panel" id="notePanel"></div>
            <div class="think-note" id="noteNote"></div>
            <div class="burst-layer" id="noteBurst" aria-hidden="true"></div>
          `,
          init: () => {
            const noteGrid = document.getElementById("noteGrid");
            const notePanel = document.getElementById("notePanel");
            const noteNote = document.getElementById("noteNote");
            const notesCount = document.getElementById("notesCount");
            const noteBurst = document.getElementById("noteBurst");
            let opened = 0;
            let doneTimer = null;

            function showPanel(text) {
              notePanel.textContent = text;
              notePanel.classList.remove("show");
              void notePanel.offsetWidth;
              notePanel.classList.add("show");
            }

            function openNote(index, button) {
              if (button.classList.contains("done")) return;
              opened += 1;
              button.classList.add("done");
              button.disabled = true;
              notesCount.textContent = `${opened}/${loveNotes.length}`;
              showPanel(loveNotes[index].text);
              popHeartsAt(noteGrid, button.offsetLeft + button.offsetWidth / 2, button.offsetTop + 10, 8);
              beep(680);
              if (opened >= loveNotes.length) {
                noteNote.textContent = "Все письма открыты. Сердце просит продолжения 💖";
                burstHearts(noteBurst, 22);
                fireConfetti();
                doneTimer = setTimeout(() => {
                  nextStep();
                }, 1700);
              }
            }

            noteGrid.querySelectorAll("button").forEach((button) => {
              const index = Number(button.dataset.index || 0);
              button.addEventListener("click", () => openNote(index, button));
            });

            addCleanup(() => clearTimeout(doneTimer));
            focusPrimary();
          },
        },
        4: {
          template: () => `
            <h2>Поймай 5 сердечек 💗</h2>
            <p class="muted">Каждое сердечко открывает причину, почему я тебя люблю.</p>
            <div class="test-meta">Причины: <span id="catchCount">0/5</span></div>
            <div class="arena" id="heartArena">
              <button class="runner-heart" id="runnerHeart" type="button" aria-label="Поймать сердечко">❤️</button>
            </div>
            <div class="reason-popup" id="reasonPopup"></div>
            <div class="think-note" id="heartNote"></div>
          `,
          init: () => {
            state.heartsCaught = 0;
            const arena = document.getElementById("heartArena");
            const heart = document.getElementById("runnerHeart");
            const countEl = document.getElementById("catchCount");
            const reasonPopup = document.getElementById("reasonPopup");
            const heartNote = document.getElementById("heartNote");
            const size = 56;
            let rafId = null;
            let doneTimer = null;
            let pointer = { x: null, y: null };
            let bounds = arena.getBoundingClientRect();
            let pos = {
              x: (bounds.width - size) / 2,
              y: (bounds.height - size) / 2,
            };
            let vel = { x: 2.2, y: 1.7 };

            function updateBounds() {
              bounds = arena.getBoundingClientRect();
            }

            function onMove(event) {
              const rect = arena.getBoundingClientRect();
              pointer.x = event.clientX - rect.left;
              pointer.y = event.clientY - rect.top;
            }

            function onTouch(event) {
              const touch = event.touches[0];
              if (!touch) return;
              const rect = arena.getBoundingClientRect();
              pointer.x = touch.clientX - rect.left;
              pointer.y = touch.clientY - rect.top;
            }

            function tick() {
              if (pointer.x !== null && pointer.y !== null) {
                const dx = pos.x + size / 2 - pointer.x;
                const dy = pos.y + size / 2 - pointer.y;
                const distance = Math.hypot(dx, dy);
                if (distance < 120) {
                  const push = (120 - distance) / 120;
                  vel.x += (dx / (distance || 1)) * push * 1.6;
                  vel.y += (dy / (distance || 1)) * push * 1.6;
                }
              }

              if (Math.random() < 0.04) {
                vel.x += (Math.random() - 0.5) * 1.4;
                vel.y += (Math.random() - 0.5) * 1.4;
              }

              vel.x *= 0.97;
              vel.y *= 0.97;
              pos.x += vel.x;
              pos.y += vel.y;

              if (pos.x < 0) {
                pos.x = 0;
                vel.x = Math.abs(vel.x);
              } else if (pos.x > bounds.width - size) {
                pos.x = bounds.width - size;
                vel.x = -Math.abs(vel.x);
              }
              if (pos.y < 0) {
                pos.y = 0;
                vel.y = Math.abs(vel.y);
              } else if (pos.y > bounds.height - size) {
                pos.y = bounds.height - size;
                vel.y = -Math.abs(vel.y);
              }

              heart.style.transform = `translate(${pos.x}px, ${pos.y}px)`;
              rafId = requestAnimationFrame(tick);
            }

            function showReason(index) {
              reasonPopup.innerHTML = `<strong>Причина №${index}</strong><div>${heartReasons[index - 1]}</div>`;
              reasonPopup.classList.remove("show");
              void reasonPopup.offsetWidth;
              reasonPopup.classList.add("show");
            }

            function randomJump() {
              pos.x = Math.random() * (bounds.width - size);
              pos.y = Math.random() * (bounds.height - size);
              vel.x = (Math.random() - 0.5) * 6;
              vel.y = (Math.random() - 0.5) * 6;
            }

            heart.addEventListener("click", () => {
              if (state.heartsCaught >= 5) return;
              state.heartsCaught += 1;
              countEl.textContent = `${state.heartsCaught}/5`;
              showReason(state.heartsCaught);
              popHeartsAt(arena, pos.x + size / 2, pos.y + size / 2, 10);
              beep(780);
              if (state.heartsCaught >= 5) {
                heart.classList.add("caught");
                heart.disabled = true;
                heartNote.textContent = "Все причины открыты. Готовлю следующий сюрприз… 💖";
                popHeartsAt(arena, bounds.width / 2, bounds.height / 2, 16);
                cancelAnimationFrame(rafId);
                doneTimer = setTimeout(() => {
                  nextStep();
                }, 1600);
              } else {
                randomJump();
              }
              focusPrimary();
            });

            arena.addEventListener("mousemove", onMove);
            arena.addEventListener("touchmove", onTouch, { passive: true });
            window.addEventListener("resize", updateBounds);
            updateBounds();
            rafId = requestAnimationFrame(tick);

            addCleanup(() => cancelAnimationFrame(rafId));
            addCleanup(() => clearTimeout(doneTimer));
            addCleanup(() => arena.removeEventListener("mousemove", onMove));
            addCleanup(() => arena.removeEventListener("touchmove", onTouch));
            addCleanup(() => window.removeEventListener("resize", updateBounds));
          },
        },
          5: {
            template: () => `
              <h2>Собери букет любви 🌸</h2>
              <p class="muted">Открой все лепестки, и букет будет готов.</p>
            <div class="test-meta">Лепестки: <span id="petalCount">0/4</span></div>
            <div class="petal-grid" id="petalGrid">
              ${bouquetPetals
                .map(
                  (petal, index) =>
                    `<button class="petal-btn" type="button" data-index="${index}">${petal.label}</button>`
                )
                .join("")}
            </div>
            <div class="petal-panel" id="petalPanel"></div>
            <div class="think-note" id="petalNote"></div>
            <div class="burst-layer" id="petalBurst" aria-hidden="true"></div>
          `,
          init: () => {
            const petalGrid = document.getElementById("petalGrid");
            const petalPanel = document.getElementById("petalPanel");
            const petalNote = document.getElementById("petalNote");
            const petalCount = document.getElementById("petalCount");
            const petalBurst = document.getElementById("petalBurst");
            let opened = 0;
            let doneTimer = null;

            function showPanel(text) {
              petalPanel.textContent = text;
              petalPanel.classList.remove("show");
              void petalPanel.offsetWidth;
              petalPanel.classList.add("show");
            }

            function openPetal(index, button) {
              if (button.classList.contains("done")) return;
              opened += 1;
              button.classList.add("done");
              button.disabled = true;
              petalCount.textContent = `${opened}/${bouquetPetals.length}`;
              showPanel(bouquetPetals[index].text);
              popHeartsAt(petalGrid, button.offsetLeft + button.offsetWidth / 2, button.offsetTop + 10, 8);
              beep(700);
              if (opened >= bouquetPetals.length) {
                petalNote.textContent = "Букет собран. Сердце улыбается тебе 💐";
                burstHearts(petalBurst, 24);
                fireConfetti();
                doneTimer = setTimeout(() => {
                  nextStep();
                }, 1700);
              }
            }

            petalGrid.querySelectorAll("button").forEach((button) => {
              const index = Number(button.dataset.index || 0);
              button.addEventListener("click", () => openPetal(index, button));
            });

              addCleanup(() => clearTimeout(doneTimer));
              focusPrimary();
            },
          },
          6: {
            template: () => `
              <h2>100 причин, почему я тебя люблю 💖</h2>
              <p class="muted">Отметь каждую причину. Пока не будет 100 из 100, дальше не пустит.</p>
              <div class="test-meta">Отмечено: <span id="reasonCount">0/100</span></div>
              <div class="reason-scroll" id="reasonScroll">
                <div class="contract-list" id="reasonList">
                  ${loveReasons
                    .map(
                      (reason, index) =>
                        `<label class="contract-item"><input type="checkbox" data-reason="${index}" />${
                          index + 1
                        }. ${reason}</label>`
                    )
                    .join("")}
                </div>
              </div>
              <div class="hint" id="reasonHint"></div>
              <div class="think-note" id="reasonNote"></div>
              <div class="burst-layer" id="reasonBurst" aria-hidden="true"></div>
            `,
            init: () => {
              const reasonList = document.getElementById("reasonList");
              const reasonCount = document.getElementById("reasonCount");
              const reasonHint = document.getElementById("reasonHint");
              const reasonNote = document.getElementById("reasonNote");
              const reasonBurst = document.getElementById("reasonBurst");
              let doneTimer = null;
              let completed = false;

              function updateReasonState() {
                const count = [...reasonList.querySelectorAll("input[type='checkbox']")].filter(
                  (input) => input.checked
                ).length;
                reasonCount.textContent = `${count}/${loveReasons.length}`;
                if (count < loveReasons.length) {
                  reasonHint.textContent = "Нужно отметить все 100 причин, милая.";
                  return;
                }
                if (completed) return;
                completed = true;
                reasonHint.textContent = "";
                reasonNote.textContent = "Все 100 причин подтверждены. Сердце поёт и идёт дальше 💖";
                [...reasonList.querySelectorAll("input")].forEach((input) => (input.disabled = true));
                burstHearts(reasonBurst, 26);
                fireConfetti();
                beep(760);
                doneTimer = setTimeout(() => {
                  nextStep();
                }, 1900);
              }

              reasonList.addEventListener("change", updateReasonState);
              updateReasonState();
              addCleanup(() => clearTimeout(doneTimer));
              addCleanup(() => reasonList.removeEventListener("change", updateReasonState));
              focusPrimary();
            },
          },
          7: {
            template: () => `
              <h2>ДОГОВОР №14/02: «Маша — моя валентинка» 💖</h2>
              <p class="muted">Поставь галочки. Юристы сердца строгие, но добрые.</p>
            <div class="contract-list" id="contractList">
              <label class="contract-item"><input type="checkbox" data-index="0" />Согласна получать обнимашки без предупреждения</label>
              <label class="contract-item"><input type="checkbox" data-index="1" />Согласна на поцелуи и заботу в неожиданные моменты</label>
              <label class="contract-item"><input type="checkbox" data-index="2" />Согласна, что мы команда, даже если спорим</label>
              <label class="contract-item"><input type="checkbox" data-index="3" />Согласна, что ты мой милый котенок (не оспаривается)</label>
              <label class="contract-item"><input type="checkbox" data-index="4" />Согласна принимать мою любовь всегда, без условий</label>
            </div>
            <div class="hint" id="contractHint"></div>
            <div class="btn-row">
              <button class="btn primary pulse" id="signBtn" type="button" disabled>Подписать, бусинка ❤️</button>
            </div>
            <div class="signature hidden" id="signature">Подписано: Маша ✅ Статус: официальная валентинка (уровень: легендарный). Любовь подтверждена.</div>
          `,
          init: () => {
            state.contractChecks = [false, false, false, false, false];
            state.contractSigned = false;
            const list = document.getElementById("contractList");
            const signBtn = document.getElementById("signBtn");
            const hint = document.getElementById("contractHint");
            const signature = document.getElementById("signature");
            const minChecks = 4;
            let doneTimer = null;

            function updateState() {
              const count = [...list.querySelectorAll("input[type='checkbox']")].filter(
                (input) => input.checked
              ).length;
              signBtn.disabled = count < minChecks;
              hint.textContent =
                count < minChecks
                  ? "Маловато милоты в форме. Добавь ещё одну галочку, милая."
                  : "";
            }

            list.addEventListener("change", updateState);

            signBtn.addEventListener("click", () => {
              if (signBtn.disabled) return;
              beep(700);
              state.contractSigned = true;
              signature.classList.remove("hidden");
              signBtn.disabled = true;
              [...list.querySelectorAll("input")].forEach((input) => (input.disabled = true));
              hint.textContent = "";
              doneTimer = setTimeout(() => {
                nextStep();
              }, 1800);
              focusPrimary();
            });

              updateState();
              addCleanup(() => clearTimeout(doneTimer));
            },
          },
          8: {
            template: () => `
              <h2>Секретная комната 🔒</h2>
              <p class="muted">Только для Маши. Подсказка: пароль — наша любимая фраза про процесс 😌</p>
            <div class="btn-row">
              <input id="secretInput" class="text-input" type="text" placeholder="Пароль для бусинки" aria-label="Пароль" />
              <button class="btn primary" id="secretBtn" type="button">Открыть</button>
            </div>
            <div class="hint" id="secretHint"></div>
            <div class="secret-boxes hidden" id="secretBoxes">
              <div class="secret-box">Ты мой милый котенок. Я люблю тебя больше всего.</div>
              <div class="secret-box">Какие бы споры или недопонимания ни были — я всегда буду любить тебя.</div>
              <div class="secret-box">Ты самая красивая на свете. И моя самая любимая.</div>
            </div>
            <div class="think-note" id="secretNote"></div>
          `,
          init: () => {
            state.secretUnlocked = false;
            const input = document.getElementById("secretInput");
            const btn = document.getElementById("secretBtn");
            const hint = document.getElementById("secretHint");
            const boxes = document.getElementById("secretBoxes");
            const secretNote = document.getElementById("secretNote");
            let doneTimer = null;

            function unlock() {
              const value = input.value.trim().toLowerCase();
              if (value === "наебательный процесс") {
                state.secretUnlocked = true;
                boxes.classList.remove("hidden");
                hint.textContent = "Доступ открыт для бусинки ✅";
                secretNote.textContent = "Секреты раскрыты. Переходим дальше… 💖";
                beep(760);
                doneTimer = setTimeout(() => {
                  nextStep();
                }, 2000);
                focusPrimary();
              } else {
                hint.textContent = "Хм… это не наш пароль. Попробуй ещё раз, милая.";
                beep(440);
              }
            }

            btn.addEventListener("click", unlock);
            input.addEventListener("keydown", (event) => {
              if (event.key === "Enter") unlock();
            });
              focusPrimary();
              addCleanup(() => clearTimeout(doneTimer));
            },
          },
          9: {
            template: () => `
              <h2>Маша, будешь моей валентинкой? 💘</h2>
              <p class="muted">Я люблю тебя больше всего и хочу быть рядом всегда. Нажми «Да» 20 раз, чтобы запечатать это навсегда.</p>
            <div class="btn-row">
              <button class="btn primary pulse" id="yesBtn" type="button">Да</button>
            </div>
            <div class="think-note" id="yesNote">Нажми «Да»: 0/20</div>
            <div class="think-zone" id="thinkZone" aria-label="Поле для ловли мысли">
              <button class="btn secondary dodge-btn" id="thinkBtn" type="button">Я еще подумаю</button>
            </div>
            <div class="think-note" id="thinkNote">«Я еще подумаю» — шустрая мысль. Лови, если сможешь.</div>
            <div class="small-note">Ответ «нет» временно недоступен по техническим причинам (потому что я люблю тебя).</div>
            <div class="burst-layer" id="finalBurst" aria-hidden="true"></div>
          `,
          init: () => {
            const yesBtn = document.getElementById("yesBtn");
            const thinkZone = document.getElementById("thinkZone");
            const thinkBtn = document.getElementById("thinkBtn");
            const thinkNote = document.getElementById("thinkNote");
            const yesNote = document.getElementById("yesNote");
            const finalBurst = document.getElementById("finalBurst");
            let autoAdvance = null;
            const requiredClicks = 20;
            state.yesClicks = 0;

            function updateYesNote() {
              yesNote.textContent = `Нажми «Да»: ${state.yesClicks}/${requiredClicks}`;
              const scale = 1 + state.yesClicks * 0.03;
              yesBtn.style.setProperty("--scale", scale.toFixed(2));
            }

            function setThinkPosition(x, y) {
              thinkBtn.style.left = `${x}px`;
              thinkBtn.style.top = `${y}px`;
            }

            function randomThinkPosition(avoidPoint) {
              const maxX = Math.max(0, thinkZone.clientWidth - thinkBtn.offsetWidth);
              const maxY = Math.max(0, thinkZone.clientHeight - thinkBtn.offsetHeight);
              let x = Math.random() * maxX;
              let y = Math.random() * maxY;

              if (avoidPoint) {
                for (let i = 0; i < 6; i++) {
                  const dx = x + thinkBtn.offsetWidth / 2 - avoidPoint.x;
                  const dy = y + thinkBtn.offsetHeight / 2 - avoidPoint.y;
                  if (Math.hypot(dx, dy) > 120) break;
                  x = Math.random() * maxX;
                  y = Math.random() * maxY;
                }
              }

              setThinkPosition(x, y);
            }

            function handleDodge(event) {
              const rect = thinkZone.getBoundingClientRect();
              const pointerX = event.clientX - rect.left;
              const pointerY = event.clientY - rect.top;
              const btnRect = thinkBtn.getBoundingClientRect();
              const btnX = btnRect.left - rect.left + btnRect.width / 2;
              const btnY = btnRect.top - rect.top + btnRect.height / 2;
              const distance = Math.hypot(btnX - pointerX, btnY - pointerY);
              if (distance < 120) {
                randomThinkPosition({ x: pointerX, y: pointerY });
              }
            }

            thinkBtn.addEventListener("click", (event) => {
              const rect = thinkZone.getBoundingClientRect();
              const clickX = event.clientX - rect.left;
              const clickY = event.clientY - rect.top;
              popHeartsAt(thinkZone, clickX, clickY, 8);
              beep(520);
              thinkNote.textContent = "Мысль убежала, а сердце уже всё решило.";
              randomThinkPosition({ x: clickX, y: clickY });
            });

            thinkBtn.addEventListener("mouseenter", () => {
              randomThinkPosition();
            });

            const touchHandler = (event) => {
              const touch = event.touches[0];
              if (!touch) return;
              const rect = thinkZone.getBoundingClientRect();
              randomThinkPosition({ x: touch.clientX - rect.left, y: touch.clientY - rect.top });
            };

            thinkZone.addEventListener("mousemove", handleDodge);
            thinkZone.addEventListener("touchstart", touchHandler, { passive: true });

            const placeTimer = requestAnimationFrame(() => {
              thinkBtn.style.setProperty("--scale", "1");
              randomThinkPosition();
            });

            yesBtn.addEventListener("click", (event) => {
              if (state.yesClicks >= requiredClicks) return;
              state.yesClicks += 1;
              updateYesNote();
              const rect = finalBurst.getBoundingClientRect();
              popHeartsAt(finalBurst, event.clientX - rect.left, event.clientY - rect.top, 8);
              beep(760);
              if (state.yesClicks >= requiredClicks) {
                yesBtn.disabled = true;
                yesNote.textContent = "Да подтверждено навсегда ❤️";
                burstHearts(finalBurst, 28);
                fireConfetti();
                autoAdvance = setTimeout(() => {
                  nextStep();
                }, 1400);
              }
            });

            updateYesNote();
            addCleanup(() => cancelAnimationFrame(placeTimer));
            addCleanup(() => thinkZone.removeEventListener("mousemove", handleDodge));
            addCleanup(() => thinkZone.removeEventListener("touchstart", touchHandler));
              addCleanup(() => clearTimeout(autoAdvance));
              focusPrimary();
            },
          },
          10: {
            template: () => `
              <h2>Большой документ любви ❤️</h2>
              <p class="muted">Прочитай и подтверди. Тут всё серьёзно и очень мило.</p>
            <div class="doc-scroll" id="docScroll">
              ${buildAgreementHtml()}
            </div>
            <div class="contract-list doc-checks" id="docChecks">
              <label class="contract-item"><input type="checkbox" data-doc="0" />Я внимательно прочитала и согласна ❤️</label>
              <label class="contract-item"><input type="checkbox" data-doc="1" />Я подтверждаю, что я бусинка и прекрасная 💗</label>
              <label class="contract-item"><input type="checkbox" data-doc="2" />Я подтверждаю, что буду валентинкой Иракли 💘</label>
            </div>
            <div class="hint" id="docHint"></div>
            <div class="btn-row">
              <button class="btn primary pulse" id="docSignBtn" type="button" disabled>Подписать документ ❤️</button>
              <button class="btn secondary hidden" id="docPdfBtn" type="button">Скачать PDF</button>
            </div>
            <div class="signature hidden" id="docSignature"></div>
            <div class="finale hidden" id="finale">
              <h3>Финальный сюрприз</h3>
              <p>Теперь всё официально и очень-очень нежно. Хочешь запустить салют любви? 💘</p>
              <div class="btn-row">
                <button class="btn primary" id="finaleBtn" type="button">Запустить салют любви</button>
              </div>
              <p class="small-note">Спасибо, что ты есть, мой милый котенок. Ты мой самый любимый финал. 💖</p>
            </div>
            <div class="burst-layer" id="docBurst" aria-hidden="true"></div>
          `,
          init: () => {
            const docChecks = document.getElementById("docChecks");
            const docHint = document.getElementById("docHint");
            const signBtn = document.getElementById("docSignBtn");
            const pdfBtn = document.getElementById("docPdfBtn");
            const signature = document.getElementById("docSignature");
            const finale = document.getElementById("finale");
            const finaleBtn = document.getElementById("finaleBtn");
            const docBurst = document.getElementById("docBurst");
            const minChecks = 3;

            function updateDocState() {
              const count = [...docChecks.querySelectorAll("input[type='checkbox']")].filter(
                (input) => input.checked
              ).length;
              signBtn.disabled = count < minChecks;
              docHint.textContent =
                count < minChecks ? "Чтобы подписать, поставь все галочки, милая." : "";
            }

            signBtn.addEventListener("click", () => {
              if (signBtn.disabled) return;
              const dateStr = new Date().toLocaleDateString("ru-RU");
              state.signatureText = `Я, ${personNames.her}, подтверждаю согласие быть валентинкой ${personNames.him} и принимаю нашу любовь навсегда.`;
              state.signatureDate = dateStr;
              signature.innerHTML = `<strong>Подтверждение:</strong> ${state.signatureText} Дата: ${dateStr}. ❤️`;
              signature.classList.remove("hidden");
              pdfBtn.classList.remove("hidden");
              finale.classList.remove("hidden");
              signBtn.disabled = true;
              [...docChecks.querySelectorAll("input")].forEach((input) => (input.disabled = true));
              docHint.textContent = "";
              burstHearts(docBurst, 24);
              fireConfetti();
              beep(760);
              focusPrimary();
            });

            pdfBtn.addEventListener("click", () => {
              const dateLine = state.signatureDate ? `Дата: ${state.signatureDate}.` : "";
              downloadAgreementPdf(state.signatureText, dateLine);
              beep(640);
            });

            finaleBtn.addEventListener("click", () => {
              fireConfetti();
              burstHearts(docBurst, 30);
              showOverlay(
                "Салют любви!",
                "Ты мой милый котенок и самая красивая на свете. Я люблю тебя больше всего."
              );
            });

            docChecks.addEventListener("change", updateDocState);
            updateDocState();
            focusPrimary();
          },
        },
      };

      function renderStep() {
        runCleanups();
        updateProgress();
        card.innerHTML = steps[state.step].template();
        animateCard();
        steps[state.step].init();
      }

      function nextStep() {
        if (state.step < totalSteps) {
          state.step += 1;
          renderStep();
        }
      }

      function fireConfetti() {
        const amount = 36;
        for (let i = 0; i < amount; i++) {
          const confetti = document.createElement("span");
          confetti.className = "confetti";
          confetti.textContent = loveSymbols[Math.floor(Math.random() * loveSymbols.length)];
          confetti.style.left = `${Math.random() * 100}vw`;
          confetti.style.setProperty("--dur", `${2.6 + Math.random() * 1.6}s`);
          confetti.style.setProperty("--rot", `${Math.random() * 120 - 60}deg`);
          confetti.style.fontSize = `${14 + Math.random() * 18}px`;
          document.body.appendChild(confetti);
          setTimeout(() => confetti.remove(), 4200);
        }
      }

      initFloatingHearts();
      setupTapHearts();
      renderStep();
    </script>
  </body>
</html>
